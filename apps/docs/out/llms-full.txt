# API Reference



import { Callout } from 'fumadocs-ui/components/callout';

<Callout>
  All authenticated endpoints require an `Authorization: Bearer <token>` header. Obtain a token via the magic-link flow.
</Callout>

Base URL [#base-url]

```
http://localhost:8080    (development)
https://your-domain.com  (production)
```

***

Authentication [#authentication]

POST /api/magic-link [#post-apimagic-link]

Request a login link. If the email is registered, a link is sent.

**Public â€” no auth required**

```json
// Request
POST /api/magic-link
Content-Type: application/json

{
  "email": "user@company.com"
}

// Response 200
{
  "message": "if that email is registered, a link has been sent"
}
```

The response is identical whether the email exists or not (to prevent user enumeration).

***

GET /api/magic-login [#get-apimagic-login]

Validates a magic link token and issues a session. Called automatically when a user clicks their login link.

**Public â€” token passed as query param**

```
GET /api/magic-login?token=<jwt>
```

On success, redirects to `/auth-callback?token=<session-jwt>`.

| Response | Description                            |
| -------- | -------------------------------------- |
| `302`    | Redirect to `/auth-callback?token=...` |
| `400`    | Missing token                          |
| `401`    | Invalid or expired token               |

***

GET /api/me [#get-apime]

Returns the currently authenticated user.

**Auth required**

```json
// Response 200
{
  "id": "uuid",
  "email": "user@company.com",
  "name": "Jane Smith",
  "role": "Staff",
  "created_by": "uuid",
  "created_at": "2024-01-15T10:30:00Z"
}
```

***

Policies [#policies]

GET /api/policies [#get-apipolicies]

List all policies with the current user's acknowledgement status.

**Auth required**

```json
// Response 200
[
  {
    "id": "uuid",
    "title": "Employee Code of Conduct",
    "current_version_id": "uuid",
    "status": "Published",
    "department": "Human Resources",
    "created_at": "2024-01-01T00:00:00Z",
    "acknowledged": false
  }
]
```

***

GET /api/policies/:id [#get-apipoliciesid]

Get full policy detail with the current version content.

**Auth required**

```json
// Response 200
{
  "policy": {
    "id": "uuid",
    "title": "Employee Code of Conduct",
    "current_version_id": "uuid",
    "status": "Published",
    "department": "Human Resources",
    "created_at": "2024-01-01T00:00:00Z"
  },
  "current_version": {
    "id": "uuid",
    "policy_id": "uuid",
    "content": "# Employee Code of Conduct\n\n...",
    "version_string": "v1.0.0",
    "changelog": "Initial release",
    "created_at": "2024-01-01T00:00:00Z"
  },
  "acknowledged": false
}
```

| Code  | Description      |
| ----- | ---------------- |
| `200` | Success          |
| `404` | Policy not found |

***

GET /api/policies/:id/versions [#get-apipoliciesidversions]

Get full version history for a policy, ordered newest first.

**Auth required**

```json
// Response 200
[
  {
    "id": "uuid",
    "policy_id": "uuid",
    "content": "...",
    "version_string": "v1.1.0",
    "changelog": "Updated section 3",
    "created_at": "2024-03-01T00:00:00Z"
  },
  {
    "id": "uuid",
    "policy_id": "uuid",
    "content": "...",
    "version_string": "v1.0.0",
    "changelog": "Initial release",
    "created_at": "2024-01-01T00:00:00Z"
  }
]
```

***

POST /api/policies/:id/acknowledge [#post-apipoliciesidacknowledge]

Record the current user's acknowledgement of the current version.

**Auth required**

```json
// Response 201
{
  "id": "uuid",
  "user_id": "uuid",
  "policy_version_id": "uuid",
  "timestamp": "2024-04-10T14:22:00Z",
  "signature_hash": "sha256hex..."
}
```

| Code  | Description                                 |
| ----- | ------------------------------------------- |
| `201` | Acknowledgement recorded                    |
| `400` | Policy not published, or no current version |
| `409` | Already acknowledged this version           |

***

Admin â€” Users [#admin--users]

<Callout type="error">
  These endpoints require 

  **Admin**

   role.
</Callout>

GET /api/users [#get-apiusers]

List all users.

```json
// Response 200
[
  {
    "id": "uuid",
    "email": "admin@company.com",
    "name": "Policy Admin",
    "role": "Admin",
    "created_at": "2024-01-01T00:00:00Z"
  }
]
```

***

POST /api/users [#post-apiusers]

Create a new user and send them a welcome email with a magic login link.

```json
// Request
{
  "email": "jane@company.com",
  "name": "Jane Smith",
  "role": "Staff"   // "Staff" (default) or "Admin"
}

// Response 201
{
  "id": "uuid",
  "email": "jane@company.com",
  "name": "Jane Smith",
  "role": "Staff",
  "created_by": "uuid",
  "created_at": "2024-04-10T14:00:00Z"
}
```

| Code  | Description                             |
| ----- | --------------------------------------- |
| `201` | User created, welcome email sent        |
| `400` | Missing required fields or invalid role |
| `409` | Email already registered                |

***

Admin â€” Policies [#admin--policies]

<Callout type="error">
  These endpoints require 

  **Admin**

   role.
</Callout>

POST /api/policies [#post-apipolicies]

Create a new policy (starts in `Draft` status).

```json
// Request
{
  "title": "Remote Work Policy",
  "department": "Operations"
}

// Response 201
{
  "id": "uuid",
  "title": "Remote Work Policy",
  "current_version_id": null,
  "status": "Draft",
  "department": "Operations",
  "created_at": "2024-04-10T00:00:00Z"
}
```

***

PUT /api/policies/:id [#put-apipoliciesid]

Update policy title, status, or department.

```json
// Request (send only fields you want to change)
{
  "status": "Published"
}

// Response 200 â€” updated policy object
```

Valid status values: `Draft`, `Review`, `Published`, `Archived`

***

POST /api/policies/:id/versions [#post-apipoliciesidversions]

Add a new version and set it as the current version.

```json
// Request
{
  "content": "# Remote Work Policy\n\n## 1. Eligibility\n...",
  "version_string": "v1.0.0",
  "changelog": "Initial release"
}

// Response 201 â€” new version object
```

***

Admin â€” Stats [#admin--stats]

GET /api/admin/stats [#get-apiadminstats]

Returns aggregate statistics for the admin dashboard.

```json
// Response 200
{
  "stats": {
    "total_users": 42,
    "total_policies": 8,
    "published_count": 5,
    "draft_count": 2,
    "review_count": 1,
    "archived_count": 0,
    "total_acknowledgements": 186
  },
  "ack_counts": [
    {
      "policy_id": "uuid",
      "title": "Employee Code of Conduct",
      "ack_count": 38
    }
  ]
}
```

***

Error Responses [#error-responses]

All errors follow the Echo default format:

```json
{
  "message": "human-readable error description"
}
```

| Code  | Meaning                                                                |
| ----- | ---------------------------------------------------------------------- |
| `400` | Bad request â€” check your payload                                       |
| `401` | Not authenticated â€” include Bearer token                               |
| `403` | Forbidden â€” Admin role required                                        |
| `404` | Resource not found                                                     |
| `409` | Conflict â€” duplicate (e.g. email already exists, already acknowledged) |
| `500` | Internal server error                                                  |


# Architecture



import { Callout } from 'fumadocs-ui/components/callout';

System Overview [#system-overview]

PolicyFlow is a **single Go binary** that embeds the compiled Next.js frontend using `go:embed`. There are no external service dependencies â€” only a local SQLite file.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  ./build/policyflow                   â”‚
â”‚                                                       â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚   â”‚  Echo HTTP Server â”‚   â”‚  Embedded Next.js SPA   â”‚ â”‚
â”‚   â”‚  /api/* routes   â”‚   â”‚  go:embed  web/out/**   â”‚ â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚            â”‚                        â”‚                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚   â”‚              Request Router                     â”‚ â”‚
â”‚   â”‚  /api/*  â†’ API handlers                         â”‚ â”‚
â”‚   â”‚  /*      â†’ Static file server (SPA fallback)    â”‚ â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                         â”‚                             â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚   â”‚              SQLite (WAL mode)                  â”‚ â”‚
â”‚   â”‚              policyflow.db                      â”‚ â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

***

Data Model [#data-model]

```
users
  id          TEXT  PK
  email       TEXT  UNIQUE
  name        TEXT
  role        TEXT  Admin | Staff
  created_by  TEXT  FK â†’ users.id
  created_at  DATETIME

policies
  id                  TEXT  PK
  title               TEXT
  current_version_id  TEXT  FK â†’ policy_versions.id
  status              TEXT  Draft | Review | Published | Archived
  department          TEXT
  created_at          DATETIME

policy_versions
  id             TEXT  PK
  policy_id      TEXT  FK â†’ policies.id
  content        TEXT  (Markdown)
  version_string TEXT  (e.g. v1.0.0)
  changelog      TEXT
  created_at     DATETIME

acknowledgements
  id                TEXT  PK
  user_id           TEXT  FK â†’ users.id
  policy_version_id TEXT  FK â†’ policy_versions.id
  timestamp         DATETIME
  signature_hash    TEXT  SHA-256(user_id + version_id + timestamp)
  UNIQUE(user_id, policy_version_id)
```

***

Policy State Machine [#policy-state-machine]

```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Draft   â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                        â”‚
             â”‚ Admin moves to Review         â”‚
             â–¼                              â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
        â”‚  Review  â”‚                        â”‚
        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                        â”‚
             â”‚ Admin publishes               â”‚
             â–¼                              â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚
        â”‚ Published â”‚ â”€â”€â”€ Staff acknowledges â”‚
        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                       â”‚
             â”‚ Admin archives               â”‚
             â–¼                              â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
        â”‚ Archived â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   (can return to Draft)
```

Transitions are enforced in `PUT /api/policies/:id`. The `status` field accepts: `Draft`, `Review`, `Published`, `Archived`.

***

Authentication Flow [#authentication-flow]

```
User                    Frontend               Backend
 â”‚                          â”‚                     â”‚
 â”‚  Enter email             â”‚                     â”‚
 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚                     â”‚
 â”‚                          â”‚ POST /api/magic-link â”‚
 â”‚                          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
 â”‚                          â”‚                     â”‚ Build magic JWT
 â”‚                          â”‚                     â”‚ (sub=email, type=magic, exp=24h)
 â”‚                          â”‚                     â”‚ Send email (or log)
 â”‚  Receive email           â”‚                     â”‚
 â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
 â”‚                          â”‚                     â”‚
 â”‚  Click link              â”‚                     â”‚
 â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚
 â”‚                          â”‚  GET /api/magic-login?token=...
 â”‚                          â”‚                     â”‚ Validate JWT
 â”‚                          â”‚                     â”‚ Build session JWT
 â”‚                          â”‚                     â”‚ (sub=user_id, role, exp=7d)
 â”‚                          â”‚ 302 /auth-callback?token=...
 â”‚                          â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 â”‚                          â”‚                     â”‚
 â”‚                          â”‚ Store token in localStorage
 â”‚                          â”‚ Redirect â†’ /policiesâ”‚
 â”‚                          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
```

***

Monorepo Layout [#monorepo-layout]

```
policyflow/
â”œâ”€â”€ Makefile              â† root orchestration
â”œâ”€â”€ build/
â”‚   â””â”€â”€ policyflow        â† compiled binary (gitignored)
â”œâ”€â”€ docker/
â”‚   â”œâ”€â”€ Dockerfile.backend
â”‚   â””â”€â”€ docker-compose.yml
â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ app/              â† Go + Next.js
â”‚   â”‚   â”œâ”€â”€ main.go       â† server + embed
â”‚   â”‚   â”œâ”€â”€ go.mod
â”‚   â”‚   â”œâ”€â”€ internal/
â”‚   â”‚   â”‚   â”œâ”€â”€ database/ â† schema + all queries
â”‚   â”‚   â”‚   â”œâ”€â”€ handlers/ â† auth, users, policies
â”‚   â”‚   â”‚   â”œâ”€â”€ middleware/â† JWT auth guard
â”‚   â”‚   â”‚   â”œâ”€â”€ email/    â† SMTP mailer
â”‚   â”‚   â”‚   â””â”€â”€ seed/     â† initial data
â”‚   â”‚   â””â”€â”€ web/          â† Next.js 15 (output: export)
â”‚   â”‚       â”œâ”€â”€ app/      â† App Router pages
â”‚   â”‚       â”œâ”€â”€ lib/      â† API client, auth helpers
â”‚   â”‚       â””â”€â”€ components/
â”‚   â””â”€â”€ docs/             â† Fumadocs site (this site)
â””â”€â”€ shared/               â† future: shared types, SQL migrations
```

***

Future Integration Points [#future-integration-points]

PolicyFlow is designed to be extended:

| Extension              | Hook Point                                                      |
| ---------------------- | --------------------------------------------------------------- |
| **SSO / OIDC**         | Replace magic-link handler in `internal/handlers/auth.go`       |
| **Employee import**    | New `POST /api/users/import` handler reading CSV/SCIM           |
| **LDAP sync**          | Background goroutine syncing `users` from LDAP directory        |
| **Department scoping** | Add `allowed_departments` to policies; filter in `ListPolicies` |
| **Webhooks**           | Fire events from acknowledgement/publish handlers               |


# Authentication



import { Callout } from 'fumadocs-ui/components/callout';
import { Steps, Step } from 'fumadocs-ui/components/steps';

PolicyFlow uses **magic-link authentication** â€” no passwords required. This reduces the attack surface (no password database to breach) and eliminates password-reset flows.

***

How It Works [#how-it-works]

<Steps>
  <Step>
    User requests a login link [#user-requests-a-login-link]

    The user visits PolicyFlow and enters their work email. The frontend calls:

    ```
    POST /api/magic-link
    { "email": "user@company.com" }
    ```

    The server looks up the email. If found, it builds a **magic-link JWT** and sends it by email.
  </Step>

  <Step>
    Server generates a magic-link token [#server-generates-a-magic-link-token]

    ```
    {
      "sub":  "user@company.com",
      "type": "magic",
      "iat":  <now>,
      "exp":  <now + 24h>
    }
    ```

    Signed with `HS256` using `JWT_SECRET`. The server emails:

    ```
    https://your-domain.com/api/magic-login?token=<jwt>
    ```
  </Step>

  <Step>
    User clicks the link [#user-clicks-the-link]

    The browser hits `GET /api/magic-login?token=<jwt>`. The server:

    1. Validates the JWT signature and expiry
    2. Looks up the user by email (the `sub` claim)
    3. Builds a **session JWT**
    4. Redirects to `/auth-callback?token=<session-jwt>`
  </Step>

  <Step>
    Frontend stores the session [#frontend-stores-the-session]

    The `/auth-callback` page reads the token from the URL, stores it in `localStorage`, then redirects to `/policies`.

    All subsequent API calls include `Authorization: Bearer <session-jwt>`.
  </Step>
</Steps>

***

Token Types [#token-types]

Magic-Link Token [#magic-link-token]

| Claim  | Value      |
| ------ | ---------- |
| `sub`  | User email |
| `type` | `"magic"`  |
| `exp`  | 24 hours   |

One-time in spirit â€” the server validates but doesn't mark tokens as used (acceptable for MVP). For stricter security, store used token hashes in the database.

Session Token [#session-token]

| Claim   | Value                  |
| ------- | ---------------------- |
| `sub`   | User ID (UUID)         |
| `email` | User email             |
| `role`  | `"Admin"` or `"Staff"` |
| `type`  | `"session"`            |
| `exp`   | 7 days                 |

***

Security Properties [#security-properties]

| Property                                   | Status     |
| ------------------------------------------ | ---------- |
| No password storage                        | âœ…          |
| Short-lived magic links (24h)              | âœ…          |
| HMAC-signed JWTs                           | âœ…          |
| Role-based access control                  | âœ…          |
| One-time magic links (stored invalidation) | ğŸ”œ Roadmap |
| Refresh token rotation                     | ğŸ”œ Roadmap |
| MFA                                        | ğŸ”œ Roadmap |

***

User Provisioning [#user-provisioning]

<Callout>
  PolicyFlow uses **admin-provisioned accounts** â€” users cannot self-register. An admin creates the account; the user receives a welcome email.
</Callout>

```
POST /api/users (Admin only)
{
  "email": "jane@company.com",
  "name": "Jane Smith",
  "role": "Staff"
}
```

After creation, the server immediately sends a welcome email with a magic link. No separate invitation step needed.

***

JWT Secret Rotation [#jwt-secret-rotation]

To rotate the `JWT_SECRET`:

1. Generate a new secret: `openssl rand -base64 32`
2. Update the environment variable and restart the server
3. All existing sessions are immediately invalidated â€” all users will need to log in again via magic link

For zero-downtime rotation, support for multiple secrets (current + previous) is on the roadmap.


# Deployment



import { Callout } from 'fumadocs-ui/components/callout';
import { Tabs, Tab } from 'fumadocs-ui/components/tabs';

<Callout type="warn">
  Always set a strong `JWT_SECRET` in production. Losing this secret invalidates all active sessions.
</Callout>

Before You Deploy [#before-you-deploy]

Generate a strong JWT secret:

```bash
openssl rand -base64 32
# â†’ e.g. xK2mP9qR7vN4jH8tY3wL6cE1fA5bD0uZ...
```

Set your `BASE_URL` to the public URL of your server â€” this is used in magic-link emails.

***

Docker (Recommended) [#docker-recommended]

<Tabs items={["Quick start", "With .env file", "Custom port"]}>
  <Tab value="Quick start">
    ```bash
    cd policyflow

    # Build the image
    make docker-build

    # Start with default settings (JWT_SECRET is required in production!)
    JWT_SECRET=$(openssl rand -base64 32) \
    BASE_URL=http://your-server-ip:8080 \
    docker compose -f docker/docker-compose.yml up -d
    ```
  </Tab>

  <Tab value="With .env file">
    ```bash
    cp docker/.env.example docker/.env
    # Edit docker/.env with your values

    make docker-build
    make docker-up
    ```
  </Tab>

  <Tab value="Custom port">
    ```bash
    PORT=9000 \
    JWT_SECRET=your-secret \
    BASE_URL=http://your-server:9000 \
    docker compose -f docker/docker-compose.yml up -d
    ```

    Update the `ports` mapping in `docker/docker-compose.yml` accordingly.
  </Tab>
</Tabs>

The SQLite database is persisted in a named Docker volume (`policyflow_data`). To back it up:

```bash
docker compose exec policyflow cat /data/policyflow.db > backup.db
```

***

Systemd (bare metal / VM) [#systemd-bare-metal--vm]

```bash
# Build the binary
make build

# Copy to system location
sudo cp build/policyflow /usr/local/bin/policyflow
sudo mkdir -p /var/lib/policyflow

# Create service file
sudo tee /etc/systemd/system/policyflow.service <<EOF
[Unit]
Description=PolicyFlow
After=network.target

[Service]
Type=simple
User=www-data
WorkingDirectory=/var/lib/policyflow
Environment=PORT=8080
Environment=DB_PATH=/var/lib/policyflow/policyflow.db
Environment=JWT_SECRET=your-secret-here
Environment=BASE_URL=https://policyflow.yourcompany.com
Environment=SMTP_HOST=smtp.yourprovider.com
Environment=SMTP_USER=noreply@yourcompany.com
Environment=SMTP_PASSWORD=your-smtp-password
ExecStart=/usr/local/bin/policyflow
Restart=on-failure

[Install]
WantedBy=multi-user.target
EOF

sudo systemctl daemon-reload
sudo systemctl enable --now policyflow
sudo systemctl status policyflow
```

***

Reverse Proxy [#reverse-proxy]

PolicyFlow should sit behind a TLS-terminating reverse proxy in production.

<Tabs items={["Nginx", "Caddy", "Traefik"]}>
  <Tab value="Nginx">
    ```nginx
    server {
        listen 443 ssl;
        server_name policyflow.yourcompany.com;

        ssl_certificate     /etc/letsencrypt/live/policyflow.yourcompany.com/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/policyflow.yourcompany.com/privkey.pem;

        location / {
            proxy_pass         http://127.0.0.1:8080;
            proxy_set_header   Host              $host;
            proxy_set_header   X-Real-IP         $remote_addr;
            proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;
            proxy_set_header   X-Forwarded-Proto $scheme;
        }
    }

    server {
        listen 80;
        server_name policyflow.yourcompany.com;
        return 301 https://$host$request_uri;
    }
    ```
  </Tab>

  <Tab value="Caddy">
    ```
    policyflow.yourcompany.com {
        reverse_proxy localhost:8080
    }
    ```

    Caddy automatically provisions TLS via Let's Encrypt.
  </Tab>

  <Tab value="Traefik">
    ```yaml
    # docker-compose labels approach
    services:
      policyflow:
        labels:
          - "traefik.enable=true"
          - "traefik.http.routers.policyflow.rule=Host(`policyflow.yourcompany.com`)"
          - "traefik.http.routers.policyflow.entrypoints=websecure"
          - "traefik.http.routers.policyflow.tls.certresolver=letsencrypt"
          - "traefik.http.services.policyflow.loadbalancer.server.port=8080"
    ```
  </Tab>
</Tabs>

***

SMTP Configuration [#smtp-configuration]

Without SMTP, magic links are printed to stdout (useful for development). For production:

| Provider             | SMTP\_HOST                           | SMTP\_PORT |
| -------------------- | ------------------------------------ | ---------- |
| Mailgun              | `smtp.mailgun.org`                   | `587`      |
| SendGrid             | `smtp.sendgrid.net`                  | `587`      |
| AWS SES              | `email-smtp.us-east-1.amazonaws.com` | `587`      |
| Postmark             | `smtp.postmarkapp.com`               | `587`      |
| Gmail (app password) | `smtp.gmail.com`                     | `587`      |

***

Backup & Restore [#backup--restore]

PolicyFlow stores all data in a single SQLite file.

```bash
# Backup
cp /var/lib/policyflow/policyflow.db policyflow-backup-$(date +%Y%m%d).db

# Restore
systemctl stop policyflow
cp policyflow-backup-20240101.db /var/lib/policyflow/policyflow.db
systemctl start policyflow
```

For automated backups, use SQLite's built-in online backup:

```bash
# Safe online backup (no service interruption)
sqlite3 /var/lib/policyflow/policyflow.db ".backup /backup/policyflow-$(date +%Y%m%d).db"
```

***

Environment Reference [#environment-reference]

| Variable        | Default                 | Description                                                                   |
| --------------- | ----------------------- | ----------------------------------------------------------------------------- |
| `JWT_SECRET`    | `dev-secret`            | **Required in production.** HMAC key for signing JWTs.                        |
| `DB_PATH`       | `policyflow.db`         | Path to SQLite database file.                                                 |
| `PORT`          | `8080`                  | HTTP listen port.                                                             |
| `BASE_URL`      | `http://localhost:8080` | Public URL â€” used in magic link emails.                                       |
| `SMTP_HOST`     | *(empty)*               | SMTP server hostname. Empty = log emails to stdout.                           |
| `SMTP_PORT`     | `587`                   | SMTP port (typically 587 for STARTTLS).                                       |
| `SMTP_USER`     | *(empty)*               | SMTP username.                                                                |
| `SMTP_PASSWORD` | *(empty)*               | SMTP password.                                                                |
| `SMTP_FROM`     | `SMTP_USER`             | From address shown in emails.                                                 |
| `WEB_DEV_PROXY` | *(empty)*               | Dev only: proxy frontend requests to this URL (e.g. `http://localhost:3001`). |


# Introduction



import { Callout } from 'fumadocs-ui/components/callout';
import { Cards, Card } from 'fumadocs-ui/components/card';

<Callout type="warn" title="Work in Progress">
  PolicyFlow is an MVP. Core features are functional. Production hardening, SSO, and directory import are on the roadmap.
</Callout>

**PolicyFlow** is a self-hosted, open-source policy management system that lets you:

* **Distribute policies** to your team with versioning and a clear approval workflow
* **Track acknowledgements** â€” know exactly who has read and signed each policy version
* **Authenticate without passwords** â€” staff log in via magic links sent to their work email
* **Own your data** â€” everything runs on your infrastructure, in a single Go binary

***

Why PolicyFlow? [#why-policyflow]

Most policy management tools are either expensive SaaS platforms or unwieldy compliance suites. PolicyFlow is designed to be:

| Property          | Description                                              |
| ----------------- | -------------------------------------------------------- |
| **Self-hosted**   | Run on any Linux box, VM, or container                   |
| **Zero-ops**      | SQLite â€” no Postgres, Redis, or external services needed |
| **Single binary** | Frontend + backend ships as one 17MB executable          |
| **Auditable**     | Each acknowledgement has a SHA-256 signature hash        |
| **Extensible**    | Ready for SSO, LDAP, and employee directory integration  |

***

Core Concepts [#core-concepts]

Policy Lifecycle [#policy-lifecycle]

```
Draft â†’ Review â†’ Published â†’ Archived
```

Only `Published` policies are visible to staff. Admins control all state transitions.

Versioning [#versioning]

Each policy update creates a new version (e.g. `v1.0.0`, `v1.1.0`). Staff must re-acknowledge when a new version is published.

Acknowledgements [#acknowledgements]

Each acknowledgement stores:

* `user_id` + `policy_version_id` + `timestamp`
* `signature_hash` = SHA-256 of the above â€” lightweight audit trail

Magic-Link Auth [#magic-link-auth]

No passwords. Users click a link emailed to their work address. Links expire in 24 hours; sessions last 7 days.

***

Next Steps [#next-steps]

<Cards>
  <Card title="Quickstart" href="/docs/quickstart" description="Run PolicyFlow locally in under 5 minutes" />

  <Card title="Architecture" href="/docs/architecture" description="How the system is structured" />

  <Card title="API Reference" href="/docs/api" description="Full REST API documentation" />

  <Card title="Deployment" href="/docs/deployment" description="Docker, systemd, and reverse proxy guides" />
</Cards>


# Quickstart



import { Callout } from 'fumadocs-ui/components/callout';
import { Steps, Step } from 'fumadocs-ui/components/steps';

Prerequisites [#prerequisites]

* Go 1.25+
* Node.js 22+ and pnpm 10+
* Git

***

<Steps>
  <Step>
    Clone the repository [#clone-the-repository]

    ```bash
    git clone https://github.com/yourorg/policyflow
    cd policyflow
    ```
  </Step>

  <Step>
    Build [#build]

    The `make build` command installs frontend deps, runs `next build`, then compiles the Go binary with the static files embedded:

    ```bash
    make build
    # â†’ build/policyflow  (~17MB single binary)
    ```
  </Step>

  <Step>
    Run [#run]

    ```bash
    ./build/policyflow
    # WARNING: JWT_SECRET not set â€” using insecure default (development only)
    # Seeding database with initial dataâ€¦
    #   Created admin user: admin@policyflow.local
    #   Created staff user: staff@policyflow.local
    #   Created policy: Employee Code of Conduct
    # PolicyFlow listening on :8080
    ```

    Open **[http://localhost:8080](http://localhost:8080)**.
  </Step>

  <Step>
    Log in [#log-in]

    No SMTP is configured in development, so login links are printed directly to the server log:

    ```
    ğŸ“§ EMAIL (no SMTP configured)
    To: admin@policyflow.local
    Subject: PolicyFlow â€” Your login link
    Body:
      http://localhost:8080/api/magic-login?token=eyJ...
    ```

    Copy the URL and paste it in your browser to log in as admin.
  </Step>
</Steps>

***

Development Mode (hot reload) [#development-mode-hot-reload]

Run the Go backend and Next.js dev server simultaneously:

```bash
# Terminal 1
make dev-frontend    # Next.js on :3001

# Terminal 2
make dev-backend     # Go on :8080, proxies frontend to :3001
```

Any changes to `apps/app/web/` will hot-reload in the browser. Go source changes require restarting `make dev-backend`.

***

Seed Credentials [#seed-credentials]

| Role  | Email                    |
| ----- | ------------------------ |
| Admin | `admin@policyflow.local` |
| Staff | `staff@policyflow.local` |

Use the magic-link flow above for either account. The seed only runs once â€” if you want a fresh start, run `make db-reset`.

***

Next Steps [#next-steps]

* Add real users via the **Admin â†’ Users** tab
* Create a policy and publish a version
* Configure SMTP so emails are actually delivered (see [Deployment](/docs/deployment))


# Components



Code Block [#code-block]

```js
console.log('Hello World');
```

Cards [#cards]

<Cards>
  <Card title="Learn more about Next.js" href="https://nextjs.org/docs" />

  <Card title="Learn more about Fumadocs" href="https://fumadocs.dev" />
</Cards>

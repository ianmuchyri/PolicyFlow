---
title: Authentication
description: How magic-link authentication works in PolicyFlow
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Steps, Step } from 'fumadocs-ui/components/steps';
import { Mermaid } from '@/components/mermaid';

PolicyFlow uses **magic-link authentication** â€” no passwords required. This reduces the attack surface (no password database to breach) and eliminates password-reset flows.

<Mermaid chart={`
sequenceDiagram
  actor User
  participant Frontend
  participant Backend

  User->>Frontend: Enter work email
  Frontend->>Backend: POST /api/magic-link
  Backend-->>User: Email â†’ magic link (JWT exp=24h)

  User->>Backend: GET /api/magic-login?token=â€¦
  Backend->>Backend: Validate magic JWT
  Backend->>Backend: Issue session JWT (exp=7d)
  Backend-->>Frontend: 302 /auth-callback?token=session-jwt

  Frontend->>Frontend: localStorage.setItem(token)
  Frontend-->>User: Redirect to /policies
`} />

---

## How It Works

<Steps>
<Step>

### User requests a login link

The user visits PolicyFlow and enters their work email. The frontend calls:

```
POST /api/magic-link
{ "email": "user@company.com" }
```

The server looks up the email. If found, it builds a **magic-link JWT** and sends it by email.

</Step>
<Step>

### Server generates a magic-link token

```
{
  "sub":  "user@company.com",
  "type": "magic",
  "iat":  <now>,
  "exp":  <now + 24h>
}
```

Signed with `HS256` using `JWT_SECRET`. The server emails:

```
https://your-domain.com/api/magic-login?token=<jwt>
```

</Step>
<Step>

### User clicks the link

The browser hits `GET /api/magic-login?token=<jwt>`. The server:

1. Validates the JWT signature and expiry
2. Looks up the user by email (the `sub` claim)
3. Builds a **session JWT**
4. Redirects to `/auth-callback?token=<session-jwt>`

</Step>
<Step>

### Frontend stores the session

The `/auth-callback` page reads the token from the URL, stores it in `localStorage`, then redirects to `/policies`.

All subsequent API calls include `Authorization: Bearer <session-jwt>`.

</Step>
</Steps>

---

## Token Types

### Magic-Link Token

| Claim | Value |
|---|---|
| `sub` | User email |
| `type` | `"magic"` |
| `exp` | 24 hours |

One-time in spirit â€” the server validates but doesn't mark tokens as used (acceptable for MVP). For stricter security, store used token hashes in the database.

### Session Token

| Claim | Value |
|---|---|
| `sub` | User ID (UUID) |
| `email` | User email |
| `role` | `"SuperAdmin"`, `"DeptAdmin"`, or `"Staff"` |
| `type` | `"session"` |
| `exp` | 7 days |

---

## Security Properties

| Property | Status |
|---|---|
| No password storage | âœ… |
| Short-lived magic links (24h) | âœ… |
| HMAC-signed JWTs | âœ… |
| Role-based access control | âœ… |
| One-time magic links (stored invalidation) | ðŸ”œ Roadmap |
| Refresh token rotation | ðŸ”œ Roadmap |
| MFA | ðŸ”œ Roadmap |

---

## User Provisioning

<Callout>
  PolicyFlow uses **admin-provisioned accounts** â€” users cannot self-register. A SuperAdmin or DeptAdmin creates the account; the user receives a welcome email.
</Callout>

```
POST /api/users  (SuperAdmin or DeptAdmin)
{
  "email": "jane@company.com",
  "name": "Jane Smith",
  "role": "Staff",        // "Staff", "DeptAdmin", or "SuperAdmin" (SuperAdmin only)
  "department_id": "uuid" // optional; DeptAdmin callers always use their own department
}
```

After creation, the server immediately sends a welcome email with a magic link. No separate invitation step needed.

---

## JWT Secret Rotation

To rotate the `JWT_SECRET`:

1. Generate a new secret: `openssl rand -base64 32`
2. Update the environment variable and restart the server
3. All existing sessions are immediately invalidated â€” all users will need to log in again via magic link

For zero-downtime rotation, support for multiple secrets (current + previous) is on the roadmap.
